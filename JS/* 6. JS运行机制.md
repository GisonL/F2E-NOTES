# JS运行机制

>  因为JS引擎是单线程的，js总是按照规定的执行顺序，处理同步任务与异步任务。从中我们可以牵扯到js中的执行栈、调用栈、事件队列等运行机制。

### 执行栈（执行上下文栈）与调用机制

​	js中的函数存在自己的词法作用域，函数作用域。当代码从上往下解析，遇到函数的调用时，会将这个函数压入执行栈中，给这个栈节点一个标识指针（栈帧），停止调用语句后面的代码执行（单线程）并执行函数代码，进入函数进行执行上下文初始化，初始化时会进行变量预解析。

> ​	执行上下文初始化
>
> ​	创建该函数的执行环境（执行上下文EC）、this、该函数的词法作用域的引用和生成变量对象VO（活动对象AO）。接着进行预解析，将该执行环境中使用声明关键字声明的变量、函数声明，执行函数的argument属性等基本属性作为AO对象的属性。但是AO对象只会初始化argument属性（赋值形参键值对，实参没有值为undefined），变量只会进行声明不会进行初始化操作（因此在声明语句前使用变量是undefined，函数和形参哪里都能用，代码执行阶段才会修改AO对象的属性值）。包括变量预解析的这一整个过程称为执行上下文的初始化。
>
> ​	tips:未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。
>
> - 创建阶段
>
>   在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。
>
> - 代码执行阶段
>
>   创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。

​	该函数中的代码继续从上往下执行，又遇到函数调用语句时，继续将被调用函数压入执行栈中，并重复执行环境初始化操作。直到最后一个调用函数语句。

​	当执行栈中的最顶层函数执行完毕后（栈后进先出的结构），会用标识法或计数法对该环境对象中的所有属性进行垃圾回收机制。如果仍有属性被引用，则这一整条作用域链被保留（闭包，不会释放内存空间）。如果所有属性均无被引用，则销毁（释放）该执行环境，并将这一栈帧出栈，继续执行上一栈帧中的剩余代码。这就是js中的执行栈与函数的调用机制。

### Event loop 事件循环

​	JS分为同步任务和异步任务，代码执行遇到函数（同步任务）时，就把这个任务压入执行栈并执行，以此类推形成一个执行栈。在执行执行栈中的任务时遇到异步任务，会将异步任务交给其他专门的线程处理。比如主线程之外，有事件触发线程，它管理着一个任务队列，当异步任务在其他线程执行完后，就在任务队列中放置一个执行函数（与每个异步任务一一对应的事件或回调函数）。一旦执行栈中的所有同步任务执行完毕(此时执行栈为空，JS引擎线程空闲)，系统就会读取任务队列，将任务队列中的执行函数放到执行栈中（队列先进先出结构），开始执行。

> 这就是为什么有时候setTimeout的回调函数不能准时执行的原因。因为可能在推入到任务队列时，主线程还不空闲，正在执行其他代码，所以自然有误差。

​	简单的步骤描述就是：

1. 主线程运行时会产生执行栈，栈中的代码调用某些api，会产生异步任务，当异步任务达到触发时机时，会在事件队列中添加各种事件。
2. 而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调。
3. 如此循环
4. 注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件。

### 事件循环进阶：macrotask和microtask

​	es6后Promise里有了一个新的概念：microtask

​	因此，JS进一步的分为两种任务类型：macrotask和microtask，在ECMAScript中，microtask称为jobs，macrotask称为task。

​	宏任务和微任务：

1. macrotask宏任务，可以理解是每次执行栈执行的代码就是一个宏任务(包括每次从事件队列中获取到的事件回调，他也会放到执行栈中执行)
   1. 每一个task会从头到尾将这个任务执行完毕，不会执行其他。
   2. 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个task执行开始前，对页面进行重新渲染(task -> 渲染 -> task -> ...)

2. microtask微任务，可以理解是在当前task执行结束后立即执行的任务。
   1. 也就是说，在当前task任务后，下一个task之前，在渲染之前。(task ->jobs -> 渲染 -> task -> ...)
   2. 所以它的响应速度相比setTimeout会更快，因为无需等渲染。
   3. 也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕(渲染之前)

macrotask和microtask分别有什么？

1. Macrotask：主代码块、setTimeout、setInterval等(可以看到，执行栈中的任务和事件队列中的每一个事件都是一个macrotask，因为事件队列中的事件也是要放到执行栈执行的)

2. Microtask：Promise、process.nextTick等

> 在node环境中，process.nextTick的优先级高于Promise，也就是可以简单理解为：在宏任务结束后会先执行微任务队列中的nextTickQueue部分，然后才会执行微任务中的Promise部分。

再根据线程进行理解：

1. macrotask中的事件都是放在一个事件队列中的，这个队列由事件触发线程维护。
2. microtask中的所有微任务都是添加到微任务队列中，等待当前macrotask执行完毕后执行，而这个队列由JS引擎线程维护。

所以，总结以下js运行机制：

1. JS引擎线程（主线程）执行执行栈中的同步任务。
2. 同步任务执行完毕，主线程空闲，从事件触发线程维护的事件队列中查找可执行的异步任务，并放到执行栈执行。
3. 执行栈和任务队列中的都是宏任务，在执行过程中如果遇到微任务，就将它添加到微任务队列中。
4. 每个宏任务执行完毕后，立即执行当前微任务队列中的所有微任务(依次执行)。
5. 当前宏任务与微任务执行完毕（一次loop），开始检查渲染，然后GUI线程接管渲染。
6. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从任务队列中获取，因为主代码块已经在第一轮循环中执行完了，剩下了处在任务队列中的异步任务）。



> 要特别注意，同步任务和异步任务，宏任务和微任务，不要搞混了。宏任务包含同步任务和异步任务。宏任务可以是同步的（执行栈中的任务），可以是异步任务产生的事件队列中的事件（最后还是会放到执行栈执行）。微任务只能是Promise、process.nextTick等，在执行宏任务时额外产生的任务。

参考资料：http://www.dailichun.com/2018/01/21/js_singlethread_eventloop.html

