# 设计模式



> 参考：https://juejin.im/post/5afe6430518825428630bc4d#comment



### 一、 单例模式

#### 1. 两个条件：

- 确保只有一个实例
- 可以全局访问

#### 2. 适用：

​	适用于弹框实现，全局缓存

#### 3. JavaScript 中的单例模式：

​	因为JavaScript是无类的语言，而且JS中的全局对象符合单例模式这两个条件。很多时候我们把全局对象当做单例模式来使用。如：var obj = {}



### 二、策略模式

#### 1.定义：

​	根据不同参数可以命中不同的策略

#### 2. 优点：

- 能减少大量的if语句
- 复用性好

#### 3. JavaScript 中的策略模式：

​	在函数是一等公民的 JS 中, 策略模式的使用常常隐藏在高阶函数中



### 三、代理模式

#### 1.情景：

​	小明追女生 A

- 非代理模式: 小明 =花=> 女生A
- 代理模式: 小明 =花=> 让女生A的好友B帮忙 =花=> 女生A

#### 2. 代理模式的特点：

- 代理对象和本体对象具有一致的接口, 对使用者友好
- 代理模式的种类有很多, 在 JS 中最常用的为虚拟代理和缓存代理

#### 3. tip：

​	在开发时候不要先去猜测是否需要使用代理模式, 如果发现直接使用某个对象不方便时, 再来优化不迟



### 四、迭代器模式

#### 1.定义：

​	能访问到聚合对象的顺序与元素，有内部迭代和外部迭代两种方式

#### 2. 内部迭代器：

​	内部迭代器在调用的时候非常简单, 使用者不用关心迭代器内部实现的细节, 但这也是内部迭代器的缺点。比如要比较两数组是否相等, 只能在其回调函数中作文章了

#### 3. 外部迭代器：

​	相较于内部迭代器, 外部迭代器将遍历的权利转移到外部, 因此在调用的时候拥有了更多的自由性, 不过缺点是调用方式较复杂



### 五、发布订阅模式

#### 1.定义：

​	事件发布/订阅模式 (PubSub) 在异步编程中帮助我们完成更松的解耦, 甚至在 MVC、MVVC 的架构中以及设计模式中也少不了发布-订阅模式的参与。

#### 2. 优点：

​	在异步编程中实现更深的解耦

#### 3. 缺点：

​	如果过多的使用发布订阅模式, 会增加维护的难度

#### 4. 发布函数优于发布函数

​	实现思路就是把原本在 emit 里触发的函数存到 cacheList, 再转交到 on 中触发。从而实现了发布函数先于订阅函数执行



### 六、命令模式

#### 1.定义：

​	命令模式与策略模式有些类似, 在 JavaScript 中它们都是隐式的

​	重要性较低

#### 2. JavaScript 中的命令模式：

​	可以在复杂项目中可以使用命令模式将界面的代码和功能的代码交付给不同的人去写，如将按钮和命令抽离



### 七、组合模式

#### 1.定义：

- 组合模式在对象间形成树形结构
- 组合模式中基本对象和组合对象被一致对待
- 无须关心对象有多少层, 调用时只需在根部进行调用



### 八、模板方法模式

#### 1.定义：

​	在继承的基础上, 在父类中定义好执行的算法，子类中覆盖要执行的某个方法。即可默认，可覆盖



### 九、享元模式

#### 1.定义：

​	享元模式是一种优化程序性能的模式, 本质为减少对象创建的个数

​	以下情况可以使用享元模式:

- 有大量相似的对象, 占用了大量内存

- 对象中大部分状态可以抽离为外部状态



### 十、职责链模式

#### 1.定义：

​	类似多米诺骨牌, 通过请求第一个条件, 会持续执行后续的条件, 直到返回结果为止

​	重要性: 4 星, 在项目中能对 if-else 语句进行优化



### 十一、中介者模式

#### 1.定义：

​	对象和对象之间借助第三方中介者进行通信



### 十二、装饰者模式

#### 1.定义：

​	使用AOP 装饰函数，动态地给函数赋能



### 十三、状态模式

#### 1.定义：

​	将事物内部的每个状态分别封装成类, 内部状态改变会产生不同行为

​	优点: 用对象代替字符串记录当前状态, 状态易维护

​	缺点: 需编写大量状态类对象



### 十四、适配者模式

#### 1.定义：

​	主要用于解决两个接口之间不匹配的问题



### 十五、观察者模式

#### 1.定义：

​	场景一: 当观察的数据对象发生变化时, 自动调用相应函数。比如 vue 的双向绑定(Object.defineProperty，Proxy/Reflect )

​	场景二: 每当调用对象里的某个方法时, 就会调用相应'访问'逻辑。比如给测试框架赋能的 spy 函数

> ### vue 在 3.0 版本上使用 Proxy重构的原因
>
> 首先罗列 Object.defineProperty()的缺点:
>
> 1. Object.defineProperty()不会监测到数组引用不变的操作(比如push/pop等);
> 2. Object.defineProperty(只能监测到对象的属性的改变, 即如果有深度嵌套的对象则需要再次给之绑定Object.defineProperty();
>
> 关于 Proxy的优点
>
> 1. 可以劫持数组的改变;
> 2. defineProperty是对属性的劫持, Proxy是对对象的劫持;

