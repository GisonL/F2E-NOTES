# new与构造函数，instanceof与实例

### new与构造函数

​	使用new关键字可以生成一个构造函数的实例：

> function Father(name){this.name=name}
>
> let father = new Father('gison')
>
> alert(father.name) ;//gison

​	这个实例拥有构造函数中显示绑定到this的属性或方法，这一过程也称为实例化。

​	使用new关键字实例化出来的实例有两种，一就是上面直接返回带有默认属性和方法的这种，还有另外一种是当构造函数中显式return时，如果return的是非引用类型的值时，返回的依然是new创建并且绑定默认属性方法的对象，如果return的是引用类型的值(非null)时，返回的是return的对象，并且这个对象不会带有默认属性和方法。
   >  function Mother(age){this.age = age;return {age:18}}
   >  function Father(name){this.name=name;return 1};//非引用类型(除null外)都行
   >  let monther = new Monther(30)
   >  let father = new Father('gison')
   >  alert(monther.age) ;// 18
   >  alert(father);//{name:'gison'}


​	通过这个结果，可以推导出new干了几件事情：

1. 创建一个空对象{}

2. 调用构造函数，传入空对象绑定上下文，并传入参数。

3. 接收调用结果，判断结果的类型并且是否为null

4. 通过判断结果，return自己创建的对象或return这个结果

   实现代码(没做参数类型判断)：

   >  function new2(fn,…args){
   >
   >  ​	let obj = {}
   >
   >  ​	let result = fn.call(obj,…args)
   >
   >  ​	if(typeof obj === 'object' && obj !== null) {
   >
   >  ​		return result
   >
   >  ​	}else{
   >
   >  ​		return obj
   >
   >  ​	}
   >
   >  }
   >
   >  function Father(name){
   >
   >  ​	this.name = name
   >
   >  }
   >
   >  let father = new2(Father,'gison')
   >
   >  alert(father);//{name:'gison'}



### instanceof与实例

​	instanceof 的作用是判断右值的原型是否在左值的原型链上，返回布尔值。

​	实现代码（没做类型判断）：

> > 普通写法:
>
> function instanceof2 (left,right){
>
> ​	let l = left.\_\_proto\_\_
>
> ​	let r = right.prototype
>
> ​	while(true){
>
> ​		if(l === null)return false
>
> ​		if(l === r) return true
>
> ​		l = l.\_\_proto\_\_
>
> ​	}
>
> }
>
> 
>
> 递归写法:
>
> function instanceof3(left,right) {
>
> ​	let l = left.\_\_proto\_\_
>
> ​	let r = right.prototype
>
> ​	if(l === null) {
>
> ​		return false
>
> ​	}else if(l === r) {
>
> ​		return true
>
> ​	}else {
>
> ​		return instanceof3(l,right)
>
> ​	}
>
> }
>
> function Father() {}
>
> function Son() {}
>
> instanceof2(new Son(),Son)
>
> instanceof2(new Son(),Father)
>
> instanceof2(new Son(),Object)

​	因为不止要判断左值的\_\_proto\_\_属性值是否等于右值的prototype属性值，如果不等还要继续判断左值的\_\_proto\_\_的\_\_proto\_\_，因此需要用到递归或循环。

​	一些容易出错的例子：

1. Object instanceof Object ;//true

   拆解：

   - Object.\_\_proto\_\_ === Object.prototype ? ;//false
   - Object.\_\_proto\_\_.\_\_proto\_\_(Function.prototype.\_\_proto\_\_) === Object.prototype ? ;//true

2. Function instanceof Function ;//true

   拆解：

   - Function.\_\_proto\_\_ === Function.prototype ? ;//true

     > Function.\_\_proto\_\_和Function.prototype都是一个匿名函数，它的隐式原型是Object.prototype

3. Foo instanceof Foo ;//false

   拆解：

   - Foo.\_\_proto\_\_ instanceof Foo.prototype ;//false
   - Foo.\_\_proto\_\_.\_\_proto\_\_ (Function.prototype)instanceof Foo.prototype ;//false
   - Foo.\_\_proto\_\_.\_\_proto\_\_.\_\_proto\_\_ (Object.prototype)instanceof Foo.prototype ;//false
   - Foo.\_\_proto\_\_.\_\_proto\_\_.\_\_proto\_\_.\_proto\_\_  (null)instanceof Foo.prototype ;//false



​	instanceof高级用法概括：

1.所有对象和函数 instanceof Object  //true     

（因为JS万物皆对象，函数也是对象） 

2.所有函数 instanceof Function  //true      

（包括普通函数和构造函数） 

3.除Object和Function之外的构造函数 instanceof 自身  //false    

 （因为构造函数的原型链上只有Function.prototype和Object.prototype而没有它们自身的prototype）

