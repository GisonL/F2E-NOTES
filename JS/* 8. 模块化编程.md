# 模块化编程

	### 什么是模块化

1. 将一个复杂的应用程序依据一定的规则(规范)封装成几个模块(文件)，并进行组合到一起。
2. 块的内部数据与实现是私有的，只是向外部暴露一些接口(方法)与外部其他模块通信。



### 模块化的进化过程

1. 全局function模式：将不同的功能模块封装成不同的全局函数。
   - 编码：将不同的功能模块封装成不同的全局函数。(也就是封装功能，挂载到全局环境中)
   - 问题：污染变量命名空间，容易引发命名冲突或数据不安全，而且模块成员之间看不出直接关系。如模块(函数)a引用了模块b，只能在调用处可以看到依赖关系。

2. namespace模式：简单对象封装。
   - 编码：将数据和功能函数封装挂载到一个对象上，以对象调用方法的方式使用这个对象（模块）。
   - 作用：减少了全局变量，解决命名冲突。
   - 问题：数据不安全，外部可以直接修改模块内部的数据。如 module1.name = 'module2'

3. IIFE模式：匿名函数自调用(闭包)
   - 编码：将数据和行为封装到一个函数内部，通过给全局变量添加属性来向外暴露接口。
   - 作用：数据是私有的，外部只能通过暴露的方法操作。
   - 问题：无法在这个模块内使用依赖另一个模块。

4. IIFE模式增强(放大镜模式)：引入依赖
   - 编码：跟IIFE模式大致一样，在模块内部，接收一个代表自己的对象变量形参（可设置默认值），在其他模块使用这个模块时，通过实参传递这个模块到内部。也可后续给模块拓展新方法。
   - 作用：这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显（在传递实参形参初即可看到模块间的依赖）。



### 模块化的好处

1. 避免命名空间冲突(减少命名空间污染)
2. 更好的分离，按需加载
3. 更高复用性，拓展性
4. 高可维护性



### 引入多个script后出现问题

1. 请求过多：我们依赖多个模块，那样就会发送多个请求，减慢速度。
2. 依赖模糊：虽然知道哪些模块依赖什么其他模块，但是当模块数量多起来后很容易因为不了解他们的依赖关系导致加载先后顺序出错。
3. 难以维护：以上两种原因就导致了很难维护，很可能出现牵一发而动全身的情况导致项目出现严重的问题。 模块化固然有多个好处，然而一个页面需要引入多个js文件，就会出现以上这些问题。而这些问题可以通过模块化规范来解决，因此出现了开发中最流行的commonjs, AMD, ES6, CMD规范。



### 模块化规范

#### CommonJS

1. 概述：

   Node 应用由模块组成，采用 CommonJS 模块规范。每个文件就是一个模块，有自己的作用域。在一个文件里面定义的变量、函数、类，都是私有的，对其他文件不可见。在服务器端，模块的加载是运行时同步加载的；在浏览器端，模块需要提前编译打包处理。

2. 特点：
   - 所有代码都运行在模块作用域，不会污染全局作用域。
   - 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。
   - 模块加载的顺序，按照其在代码中出现的顺序。



#### AMD

1. 概述：

   CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。此外AMD规范比CommonJS规范在浏览器端实现要来着早。

2. 实现库：

   RequireJS是一个工具库，主要用于客户端的模块管理。它的模块管理遵守AMD规范，RequireJS的基本思想是，通过define方法，将代码定义为模块；通过require方法，实现代码的模块加载。



#### CMD

1. 概述：

   CMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在 Sea.js 中，所有 JavaScript 模块都遵循 CMD模块定义规范。

2. 实现库：

   Sea.js



#### ES6模块化

1. 概述：

   ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。



### 总结

- CommonJS规范主要用于服务端编程，**加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案**。

- AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。**不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅**。

- CMD规范与AMD规范很相似，都用于浏览器编程，依赖就近，延迟执行，可以很容易在Node.js中运行。**不过，依赖SPM 打包，模块的加载逻辑偏重**

- ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，**完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。**

