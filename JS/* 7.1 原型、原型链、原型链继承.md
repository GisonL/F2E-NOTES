# 原型继承与原型链

### 什么是原型

​	在JS中，万物皆对象。每个对象在被创建时，都会关联另一个对象，这个对象就是我们所说的原型，因此每一个对象都有自己的原型，并且可以从这个原型中继承属性。

#### 函数、实例对象与原型的关系

1. 每个函数都有一个prototype属性，这个属性引用着从它实例化出来的实例对象的原型。而反过来，原型也有一个constructor属性，指向引用它的函数。

2. 每个对象都有一个\_\_proto\_\_属性，这个属性引用着它自己的原型。但反过来，原型并没有属性指向这个实例，因为实例可以有多个。

3. 每个实例对象都是通过构造函数创造出来的，无论是原始包装构造函数，还是自己写的构造函数。

   

从上面的说法可以推断出一个简单的关系图：

![实例与实例原型的关系图](img/prototype3.png)

​	但有些地方需要注意一下，比如：

1. 虽然Person.prototype引用着实例的原型，但是并不等同于Person.prototype一定等于实例原型（虽然从等同关系来看是相等的），因为Person.prototype的引用是可以改变的。如：

   > let a = new Person(); //1.修改原型指向前
   >
   > a.\_\_proto\_\_ === Person.prototype; // true
   >
   > Person.prototype = {}
   >
   > a.\_\_proto\_\_  === Person.prototype; // false
   >
   > let b = new Person(); //2.修改原型指向前
   >
   > b.\_\_proto\_\_ === Person.prototype; // true
   >
   > a.\_\__proto\_\_ === b.\_\__proto\_\_ ;// false

   因此对于这种结果我们可以得出，默认情况下Person.prototype指向实例的原型(情况1)。如果更改构造函数的原型的指向，则之前的对等关系就不存在了。在更改指向后，新实例化出来的对象的原型指向新的Person.prototype(情况2)。

2. person实例也可以通过constructor属性访问到Person构造函数。

   > person.constructor === Person ;//true
   >
   > person.constructor === Person.prototype.constructor ;//true
   >
   > person.constructor === person.\_\_proto\_\_.constructor ;//true

   看上去是直接在实例上就可以查看到自己的构造函数，但实际上实例并没有这个属性。这个属性就是自己的原型上的constructor属性，因此才会指向构造函数。这也进一步证明了原型链继承的原理（通过原型链，可以访问原型链上有的，自己没有的属性和方法）。

### 原型链、原型继承

​	从上面基础的原型知识可以得出，实例可以访问自己原型上的属性和方法。

​	实际上，原型也是一个对象。本质上也是由原始包装函数Object()创建的对象。因此它也有自己的原型，构造函数，一系列对等的关系以及继承原理。相当于：

> let a = new Person()
>
> Person.prototype.\_\_proto\_\_ === Object.prototype;//true
>
> delete Person.prototype.constructor; 
>
> //删除自己的属性，继承自己原型的，如果不删除，默认是指向了Person
>
> Person.prototype.constructor === Object //true
>
> Person.prototype.constructor === Object.prototype.constructor //true
>
> //测试继承自定义属性
>
> Object.prototype.myName = '123'
>
> delete Person.prototype.myName; 
>
> Person.prototype.myName === '123';//true
>
> delete a.myName; 
>
> a.myName === '123';//true

​	因此得出结论：原型也是实例对象，也有自己的原型，所以实例对象可以访问处于同一条原型链中的对象的属性和方法。

​	在实例访问一个属性或方法时，首先查看自己身上，如果有，就用自己的。如果没有，就找自己的原型身上，如果有就用原型的。如果还没有，继续找原型的原型身上。以此类推。

​	但最终原型链的顶层对象都会指向null，也就是能访问到的最高层原型对象是Object.prototype（因为所有的对象本质上都由这个原始包装函数创建，除了函数），再向上就是null了。

​	需要注意的是，在修改了构造函数原型的指向后，需要显式的将新原型的constructor属性指回当前构造函数，否则还是指向原来的构造函数，混淆指向关系。

### 确定原型和原型链的关系

​	使用原型链后，判断原型和实例的这种继承关系方法一般有两种：

 1. 使用instanceof 操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，我们可以说person是Object和Person中任何一个类型的实例，因此这三个构造函数的结果都会返回true。

    > var person = new Person()
    >
    > person instanceof Person ;// true
    >
    > person instanceof Object;//true
    >
    > // 伪代码实现instanceof ：return left.\_\_proto\_\_ === right.prototype

2. 使用isPropertypeOf()方法，同样只要是原型链中出现过的原型，isPropertypeOf()方法就会返回true。

   > Object.propertype.isPropertypeOf(person);//true
   >
   > Person.propertype.isPropertypeOf(person);//true
   >
   > // 伪代码实现isPropertypeOf ：return this === 参数.\_\_proto\_\_

### 原型进阶：Function构造函数

​	有一个很容易混淆的概念：函数是一种对象，但不能说函数是对象的一种。因为他们之间没有包含关系，就像鸡蛋和鸡的关系。因此，对象是通过函数创建的，而函数又是一种对象。

​	既然函数又是一种对象，所以函数也有自己的原型和构造函数。而函数实例是由Function构造函数创建的。

> function a(){}
>
> a.\_\_proto\_\_ === Function.prototype ;// true
>
> a.constructor === Function;//true

​	这个都能理解，而实际上Function构造函数也有自己的原型和构造函数，只是有点特别。

> Function.\_\_proto\_\_ === Function.prototype ;//true
>
> Function.constructor === Function;//true
>
> Function.prototype.\_\_proto\_\_ === Object.prototype;//true

​	从上面可以知道Function.prototype对象的原型是Object.prototype，这个很好理解，因为Function.prototype是对象，所以它的原型是Object.prototype。

​	问题是，Function作为对象的同时，它的原型又是Function作为函数时指向的原型，看起来就像是Function既是自己的构造函数，又是自己的实例对象。因此Function.\_\_proto\_\_(作为对象时) === Function.prototype(作为构造函数时)，看上去很奇怪，但就是这么设计的，没有必要把自己绕进去，就像先有鸡还是先有蛋的问题。

​	最后附加一个知识点，Function.prototype 和 Function.\_\_proto\_\_ 都是一个匿名函数。

> Function.\_\_proto\_\_ ;//ƒ () { [native code] }
> Function.prototype;//ƒ () { [native code] }

​	这可能是唯一能解释Function.prototype和Function.\_\_proto\_\_ 相等的原因了。在原型的概念中，只有这一种特殊情况。



​	简单概括就是：每个对象都有一个内部链接指向另一个对象，这个对象称为原型。原型对象也有自己的原型，如此直到某个对象以null作为原型。null根据定义，没有原型，作为这种原型链的最后一环的存在。



参考资料：

1. https://github.com/mqyqingfeng/Blog/issues/2
2. https://www.cnblogs.com/yuanzhiguo/p/8109540.html