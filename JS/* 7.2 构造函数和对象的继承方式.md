# 构造函数和对象的继承方式

### 构造函数的继承方式



1. 原型链继承。

   优点：

   1. 可以继承父类及父类原型的属性和方法。

   缺点：

   1. 无法向父类传递参数
   2. 当原型链中包含引用类型值的原型时，该引用类型值会被所有实例共享。

2. 借用构造函数继承。

   优点：

   1. 解决了原型链继承的缺点，即可以向父类传参，实例不会共享父类中引用类型的值。

   缺点：

   1. 无法使用父类原型中的属性和方法，属性方法都必须在父类构造函数中定义，无法做到函数复用。

3. 组合继承。(相当于集合了原型链继承和借用构造函数继承的有点)

   优点：

   1. 集合了两者的优点，能实现属性方法复用，向父类传参，实例间不会共享引用类型属性的值。

   缺点：

   1. 在继承原型链和借用构造函数时，共调用了两次父类构造函数，造成了不必要的消耗。

4. 原型继承(Object.create()方法)

   优点：

   1. 函数内部以新建临时构造函数，绑定原型，返回构造函数实例的方式，实现封装好的继承方法。

   缺点：

   1. 同样会出现原型链继承中的，实例间共享引用类型属性的值的问题，也就是浅拷贝。

5. 寄生式继承(与借用构造函数和工厂函数模式类似，即创建一个仅用于封装继承过程的函数，该函数内部以某种方式来增强对象并返回)

   优点：

   1. 基于参数对象创建新的对象，拥有参数对象的所有属性和方法，并且可以拓展新属性与方法。

   缺点：

   1. 使用寄生式继承来为对象添加函数，会由于不能做到函数复用而降低效率，跟借用构造函数模式类似。

6. 寄生组合式继承(寄生组合式继承就是为了降低调用父类构造函数的开销而出现的，寄生组合式继承,集寄生式继承和组合继承的优点于一身,是实现基于类型继承的最有效方法)

   优点：

   1. 不必为了指定子类型的原型而调用超类型的构造函数，因此避免了在subClass.prototype上创建多余的属性（调用父类构造函数时绑定的，使用object()是会创建一个临时空的构造函数，绑定原型再返回实例，没有多余属性和方法）。
   2. 维护了正确的继承回朔链，还能正常使用instanceof和isPrototypeOf方法。



参考：

 	1. https://juejin.im/post/58f94c9bb123db411953691b#heading-0
 	2. https://juejin.im/post/59396c96fe88c2006afc2707



### 对象的继承方式



对象的继承说白了就是一个赋值的过程，但是由于JS有引用类型传址的特点，通常需要考虑到'牵一发而动全身'这一情况，也就是'浅拷贝'和'深拷贝'的区别。

#### 浅拷贝：

1. 遍历赋值（不区分数组与对象）：

   单纯遍历源对象，赋值到目标对象相同的key键完成继承。

2. Object.assign（对象）：

   Object.assign(targetObj,originObj1,originObj2….)

3. …扩展运算符(数组)：

   arr2 = […arr1]

4. forEach、map方法等（数组或绑定上下文处理对象）

5. Object.create(对象，新对象既拷贝对象属性方法还可以访问同一条原型链对象的属性和方法)：

   obj2 = Object.create(obj1)

#### 深拷贝：

1. 序列化再解析（不区分数组与对象）：

   obj2 = JSON.parse(JSON.stringify(obj1))

   arr2 = JSON.parse(JSON.stringify(arr1))

参考：

1. 复杂版：https://juejin.im/post/59ac1c4ef265da248e75892b
2. 复杂版2：https://juejin.im/post/5c45112e6fb9a04a027aa8fe#heading-11